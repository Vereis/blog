<!DOCTYPE html>
<html>
  <head>
  <title>Chris Bailey &ndash; Setting Up A Unix Like Development Environment On Windows 10</title>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
<header>
  <p> Chris Bailey </p>
  <nav>
    <a href=".././blog.html">Blog</a>
    <a href=".././index.html">About</a>
  </nav>
</header>

<h1>A UNIX-<em>like</em> experience on Windows</h1>

<h2>Why would you want to do that?</h2>
<p>
I've had a lot of experience developing software and generally using several
different operating systems and tend to switch between them quite often.
</p>
<p>
I've grown to adore features that Linux/BSD users take for granted, such as having
easy access to software via package managers, a <em>first class</em> CLI experience,
and the ability to tweak your OS to your hearts content.
</p>
<p>
However, as someone who has used Windows as a development environment and as
a general OS for my workstation and Surface Pro (whose Linux support is shaky
at best), I also appreciate the <em>just-works</em> aspect, the lack of driver issues
and the fact that I don't need to dualboot or play with PCIE-passthrough + Virtualization
to run Windows-exclusive software.
</p>

<h2>Where to begin?</h2>
<p>
On a high level, theres a bunch of different options you have, each with their own
pros and cons. I'm currently using technology such as <code>Erlang</code>, <code>Elixir</code>,
<code>Docker</code>, <code>Kubernetes</code>, as well as a plethora of CLI tools so
I'll focus a large part of this post on things like getting a good UNIX-like shell and
terminal emulator setup.
</p>
<p>
On the other hand, we'll also look into more niche and fun things such as running
graphical applications and achieving a more UNIX-like user experience as well, since
that stuff is more seldom spoken of.
</p>

<h2>A decent shell</h2>
<p>
So my number one priority when setting up a new machine is to configure my shell and
terminal to my liking. Aside from the fact that I'm currently mainly using more
backend-oriented languages, I also use <code>vim</code> as my preferred text editor
so I find myself pretty much living in the command line.
</p>
<p>
This is the area where you have the most choices on Windows. Before we start looking at
any of the UNIX-<em>like</em> choices however, you should ask yourself if theres any
real need to choose one.
</p>
<p>
While the default shell is fairly lackluster (as well as its terminal emulator), if you're
primarily working on stuff like <code>C#</code> or finding yourself living in an IDE
such as <code>Visual Studio</code>, you may not get much benefit from switching.
</p>
<p>
<code>Powershell</code> is also a very legitimate choice. I've used it for a few small things
here and there, and combined with <a><code>Chocolatey</code></a>, it makes a pretty nice
combination for <em>pure</em> Windows power users.
</p>
<p>
However, I don't personally use it outside of a few one-offs simply because whilst its
very powerful, I find certain things quite slow and I'm also much more used to a standard
UNIX-<em>like</em> CLI experience.
</p>
<p>
I've used the following UNIX-<em>like</em> shells on various flavours of Windows over the years,
and I'll outline the advantages and disadvantages to each approach. The main thing is that they
all differ in terms of cohesion with Windows, and compatability/neccessary workarounds with
non-standard or non-userspace utilities.
</p>

<h3>Cygwin</h3>
<p>
<a><code>Cygwin</code></a> is the oldest approach to providing a UNIX-<em>like</em> shell
I have used. It essentially just provides a library which is used to implement POSIX 
system calls as the equivalent Win32 system calls.
</p>
<p>
The downside of this is that any software you actually want to run has to be compiled against
the provided library. To work around this however, there is a <em>huge</em> repository
of software which comes bundled with <a><code>Cygwin</code></a> and can be installed by running
the graphical installer.
</p>
<p>
There is also plenty of support from the community, including, importantly: third party package 
managers to make installing software via the official repositories simple: <a><code>apt-cyg</code></a>.
</p>
<p>
When installing <a><code>Cygwin</code></a>, I try to install only the very base pre-requisites
needed for <a><code>apt-cyg</code></a> so that I can configure and install <a><code>Cygwin</code></a>
packages entirely from the shell after the fact.
</p>
<p>
To do this, you'll ideally want to install:
</p>
<ul>
  <li><code>bash</code> - <a><code>apt-cyg</code></a> is a shell script after all.</li>
  <li><code>wget</code> - used to downloading packages.</li>
  <li><code>awk</code> - not actually sure what this is used for, but we need it.</li>
  <li><code>tar</code>, <code>bzip2</code> - extracting packages.</li>
</ul>
<p>
Once you've done this, head over to the <a><code>apt-cyg</code> repo</a> and follow installation
instructions. You can then pretend you're living in a UNIX-<em>like</em> shell and install
software via the following incantation: <code>apt-cyg install vim rxvt ...</code>
</p>
<p>
<a><code>Cygwin</code></a>'s biggest major advantage is also its biggest disadvantage:
<em>it isn't UNIX</em>. <a><code>Cygwin</code></a> treats Windows as a first class OS and
you can just run Windows software from the shell. Your hard drives and external devices are
mapped by default to <code>/cygdrive/</code> (i.e. <code>C:/</code> maps to <code>/cygdrive/c</code>),
and it has <em>full access</em> to the Windows API. You can even hack <code>readline</code>
support into non-readline utilities (such as the Windows version of the <code>Erlang shell</code>)
by wrapping it with <code>rlwrap</code>.
</p>
<p>
Recompiling software explicitly <em>for <a><code>Cygwin</code></a></em> can be fairly
painful though; you'll be travelling on a road not many have travelled on before if you dare
step beyond the standard package repositories. I ended up using a mash-up of Windows applications
in the command line alongside Cygwin ones.
</p>
<p>
Because certain POSIX system calls don't map well to Win32 system calls (like <code>fork</code>),
certain things can be quite considerably slower too. Support for things like <code>Docker</code>
(which needs a Linux kernel to function) won't work either &mdash; you will have to use
<code>Docker for Windows</code> and live with the heavyweight virtualisation cost.
</p>
<p>
I also haven't had much success with the <code>x64</code> version of Cygwin, but the <code>x86</code>
version performed fine.
</p>
<p>
In short, if you don't need utilities such as <code>Docker</code>, you're just trying to
have a more UNIX-<em>like</em> command line experience, value the amazing interoperability,
or you <strong>don't run Windows 10</strong> then definitely try Cygwin.
</p>

<h3>WSL</h3>
<p>
WSL (Windows Subsystem for Linux) is a fairly recent approach to providing a UNIX-<em>like</em>
environment to Windows, developed by Microsoft themselves.
</p>
<p>
WSL is amazing and checks many of the same boxes Cygwin checks. Having used Cygwin on literally
every Windows machine I used, and having used it for years professionally, the advent of WSL
made me switch over immediately &mdash; though only because my particular usecase doesn't involve
cross compiling to Windows or anything like that.
</p>
<p>
The most immediate downside is that WSL <strong>only supports Windows 10</strong>. This might not
be an issue for you, but if you're not using Windows 10, your best choice is Cygwin.
</p>
<p>
Otherwise, you can install WSL by enabling the feature via Powershell (make sure to run as admin):
</p>
<pre>
Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux
</pre>
<p>
Restart your PC, then head on over to the Microsoft Store and install your distribution of choice.
I personally go for Ubuntu, but you can choose from a handful easily. The community has also
created tools to allow you to install other distributions such as Arch Linux. I haven't
used these tools however, so I don't have much of an opinion on them.
</p>
<p>
Once installed, your distribution of choice will be added to your start menu and you can launch
it that way. When you launch WSL, you'll essentially feel as though you're in a fresh install
of whatever distribution you chose.
</p>
<p>
WSL works somewhat similarly to Cygwin in that it provides a POSIX system call translation layer.
The main difference is that applications installed in WSL <em>are real Linux binaries</em> meaning
you lose a little bit of interoperability but you gain much more out-of-the-box support.
</p>
<p>
It also means that it shares some downsides with Cygwin, such as the slowness of certain system calls
such as <code>fork</code>.
</p>
<p>
WSL essentially feels like you're in a virtual machine, except you can also launch Windows applications
and view/edit your Windows filesystem too.
</p>
<p>
The major downside about this is that WSL doesn't treat Windows as a first class citizen.
You should never, ever use Windows applications to modify/write to your WSL filesystem as you can
corrupt file attributes and the like since Windows applications don't know about WSL at all, though
you can work around this by using WSL to work out of your Windows filesystem. You can find
your <code>C:/</code> driver mounted to <code>/mnt/c</code>.
</p>
<p>
Because no Linux kernel is present either, you'll have to resort to running Docker for Windows
as opposed to just being able to run Docker in WSL. A few other things don't work yet but WSL
is still being developed.
</p>

<h3>WSL 2</h3>
<p>
WSL 2 is another Microsoft development, which as far as I understand, is being worked on in parallel with
WSL.
</p>
<p>
WSL 2 is interesting because it gives us a real Linux kernel running in Windows. The way it does this
could be seen as a downside however: its a Virtual Machine.
</p>
<p>
To install WSL 2, you can simply follow these steps:
</p>
<ol>
  <li>
    You need to be running Windows 10 build <strong>18917</strong> or higher since right now its a technical
    preview.
  </li>
  <li>
    You need Hyper-V enabled: <br/>
    <code>
      Enable-WindowsOptionalFeature -Online -FeatureName VirtualMachinePlatform
    </code>
  </li>
  <li>
    You need WSL enabled: <br/>
    <code>
      Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux
    </code>
  </li>
  <li>
    Then, assuming you have Ubuntu installed already via the Microsoft store: <br/>
    <code>
      wsl --set-version ubuntu 2
    </code>
  </li>
</ol>
<p>
The cool thing is, we run WSL 2 as thought it was the original WSL. I don't really feel or notice any real
difference. The Virtual Machine which backs WSL 2 is super lightweight and automatically scales as you consume
and free up resources. Because we have a real Linux kernel now, we can also run things like Docker without
any workaronds! 
</p>
<p>
You'll find WSL 2 is a lot faster at certain things because Windows Defender no longer scans
new files being created / modified and all system calls are running against the kernel.
</p>
<p>
The biggest downside that presents itself is, however, that it is a Hyper-V Virtual Machine. Because Hyper-V is a
Type 1 hypervisor, what I understand happens is:
</p>
<ul>
  <li>Your Windows installation is no longer running on bare metal</li>
  <li>Hyper-V is running on bare metal and virtualizes your Windows installation (and WSL distro)</li>
  <li>Because of this, you can't run Type 2 hypervisors inside said Windows installation</li>
</ul>
<p>
On the plus side, your Linux filesystem is mounted over the network into your Windows filesystem, so you can
edit and create files in both directions now. I wasn't able to make symbolic links between filesystems however,
which is a lost feature between WSL and WSL 2.
</p>
<p>
In short, I think WSL 2 is the best choice to me personally since its everything WSL could do, but more fully fledged
with the loss of only a small amount of interoperability which is fine if I'm living in WSL anyway.
</p>

<h2>A decent terminal</h2>

<h4>MinTTY</h4>
<h4>ConEmu</h4>
<h4>Linux Terminal Emulators</h4>
<h4>Windows Terminal</h4>

<h3>Graphical Applications</h3>
<h4>Do you <em>really</em> need it?</h4>
<h4>Compatability with WSL2</h4>
<h4>X4Win XServer</h4>
<h4>VcXsrv XServer</h4>

<h3>UX</h3>
<h4>Desktop Environment</h4>
<h4>Hotkeys</h4>
<h4>Browser UX</h4>
<h4>Misc Enchancements</h4>

<footer>
  © 2017 - 2019 Chris Bailey
</footer>

</body>
</html>
